<!DOCTYPE html>
<html>
<head>
    <title>Using React with the Grails® framework</title>
    <meta name="keywords" content="grails,jvm,framework,groovy,gradle,spring-boot,gorm"/>
    <meta name="description" content="React is a powerful and exciting library, and it’s a great choice for Grails® applications."/>
    <meta name="date" content="May 28, 2016"/>
    <meta name="robots" content="all"/>
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://grails.staged.apache.org/rss.xml"/>
    <meta charset='UTF-8'/>
    <link rel='icon' href='https://grails.staged.apache.org/images/favicon.ico'/>
    <meta name='twitter:card' content='summary_large_image'/>
    <meta name='twitter:site' content='@grailsframework'/>
    <meta name='twitter:description' content='React is a powerful and exciting library, and it’s a great choice for Grails® applications.'/>
    <meta name='twitter:creator' content='@grailsframework'/>
    <meta property='og:image' content='https://grails.staged.apache.org/images/grails.png'/>
    <meta property='og:image:width' content='300'/>
    <meta property='og:image:height' content='300'/>
    <meta property='og:url' content='https://grails.staged.apache.org'/>
    <meta property='og:title' content='Using React with the Grails® framework'/>
    <meta property='og:description' content='React is a powerful and exciting library, and it’s a great choice for Grails® applications.'/>
    <meta property='og:type' content='website'/>

    <meta name='viewport' content='width=device-width, initial-scale=1'/>
    <link rel='mask-icon' href='https://grails.staged.apache.org/images/grails-pinned-icon.svg' color='feb672'/>
    <link rel='stylesheet' href='https://grails.staged.apache.org/stylesheets/screen.css'/>
    <link rel='stylesheet' href='https://grails.staged.apache.org/stylesheets/plugin.css'/>
    <link rel='stylesheet' href='https://grails.staged.apache.org/stylesheets/paginate.css'/>
    <script src='https://grails.staged.apache.org/javascripts/navigation.js'></script>
    <script src='https://grails.staged.apache.org/javascripts/paginate.js'></script>
    
    <link rel='stylesheet' href='https://grails.staged.apache.orghttps://grails.staged.apache.org/stylesheets/prism.css'/>
    <script src='https://grails.staged.apache.org/javascripts/prism.js'></script>
    <script src='https://grails.staged.apache.org/javascripts/plugins.js'></script>
</head>
<body>
<header class='mainheader'>
    <div class='content'>
        <a href='https://grails.staged.apache.org/index.html'><img class='grailslogo' src='https://grails.staged.apache.org/images/grails_logo.svg' alt='Grails Logo'/></a>
        <a href='javascript:show(&apos;topmenus&apos;, &apos;showNavigationLink&apos;)' id='showNavigationLink'
           class='mobile align-center'>Show Navigation</a>
        <div id='topmenus'>
            <nav class='secondarymenu' id='secondarymenu'>
                <ul>
                    <li><a href='https://grails.staged.apache.org/casestudies/index.html'>Case Studies</a></li>
                    <li><a href='https://grails.staged.apache.org/blog/index.html'>Blog</a></li>
                    <li><a href='https://grails.staged.apache.org/learning.html'>Learning</a></li>
                    <li><a href='https://grails.staged.apache.org/community.html'>Community</a></li>
                    <li><a href='https://grails.staged.apache.org/search.html'>Search</a></li>
                </ul>
            </nav>
            <nav class='mainmenu' id='mainmenu'>
                <ul>
                    <li><a href='https://grails.staged.apache.org/documentation.html'>Documentation</a></li>
                    <li><a href='https://grails.staged.apache.org/download.html'>Download</a></li>
                    <li><a href='https://grails.staged.apache.org/plugins.html'>Plugins</a></li>
                    <li><a href='https://guides.grails.org/index.html'>Guides</a></li>
                    <li><a href='https://grails.staged.apache.org/faq.html'>FAQ</a></li>
                    <li><a href='https://grails.staged.apache.org/support.html'>Support</a></li>
                    <li><a href='https://start.grails.org'>Forge App</a></li>
                </ul>
            </nav>
        </div>
    </div>
</header>
<article><div class='headerbar chalicesbg'>
  <div class='content'>
    <h1>
      <a href='https://grails.staged.apache.org/blog/index.html'>Grails Blog</a>
    </h1>
  </div>
</div>
<div class='content container'>
  <div class='light padded blogpost'><h1>Using React with the Grails® framework</h1>
<p><span class="author">By Zachary Klein</span></p>
<p><span class="date">May 28, 2016</span></p>
<p>Tags: <a href="https://grails.staged.apache.org/blog/tag/react.html"><span class="hashtag">#react</span></a> <a href="https://grails.staged.apache.org/blog/tag/javascript.html"><span class="hashtag">#javascript</span></a> <a href="https://grails.staged.apache.org/blog/tag/gradle.html"><span class="hashtag">#gradle</span></a></p>
<p><strong>React</strong>, the JavaScript library from Facebook, has become a popular view technology for building dynamic, testable and performant user interfaces. While not a full-fledged framework like Angular or Ember, React’s focus on functional component-based views with no (or minimal) internal state makes it a great choice when building single page applications (SPA) or even dynamic subcomponents within a page-based application.</p>
<p>Because it doesn't make assumptions about data-flow or controller logic outside of rendering the view, React relies on the developer to either provide these features directly in JavaScript or use another framework as a backend to support the React-based UI.</p>
<p>It is this flexibility, in part, that makes React an appealing choice as a modern JavaScript view layer for <strong>Grails</strong><sup>®</sup> applications. Grails provides a robust backend built upon Spring Boot, GORM, and the Groovy programming language, as well as excellent support for generating restful endpoints that can be consumed by our React application. Since Grails 3 is also based upon Gradle, we can leverage <a href="https://github.com/srs/gradle-node-plugin">Gradle’s Node plugin</a> to unify our build and testing pipeline for both Grails and React, without needing to complicate our deployment processes.</p>
<p>Finally, <strong>JSX</strong> (React's XML-like syntax for defining components and page markup) is a powerful and flexible way to create dynamic views. In the author's opinion, creating components in JSX is quite analogous to defining custom GSP tags in a Grails taglib: a function which receives state via props (GSP <code>attrs</code>) and typically (but not always) renders markup based on that state. In React's case, these components are re-rendered upon every change to the app's state, rather than being limited to page-load. This stateless component model should be understandable to Grails developers who have written <a href="https://objectcomputing.com/resources/publications/sett/december-2015-custom-gsp-tags-grails-best-kept-secret/">custom GSP tags</a>, and JSX takes this to the next level.</p>
<p>In this article, we'll demonstrate how to integrate React into a Grails 3 application, using some of Grail’s restful features to get up and running quickly. We’ll spend a bit of time getting our project set up, and get to know some of the players in a React codebase.</p>
<p>There are plenty of resources available to teach you React and restful API design, so I’m going to focus primarily on the “missing pieces” of combining React with a Grails application[1]. At the completion of this article, we'll list some resources to further your understanding of React. You'll be able to take this foundation and follow along with the same documentation, tutorials and other resources available to React developers.</p>
<h2>Building Our Foundation</h2>
<p>Let’s start with a brand new Grails 3.1.6 application, using the default web profile:</p>
<pre><code>    grails create-app com.ociweb.TodoList
</code></pre>
<p>Having run the <code>create-app</code> command, we already have a fully functioning backend application and server ready to go, and we can start up our app using the run-app command. View your new Grails application at <a href="http://localhost:8080/">http://localhost:8080</a>.</p>
<p>Let’s create our data model.</p>
<pre><code>    grails create-domain-class com.ociweb.Todo
    grails create-domain-class com.ociweb.TodoList
</code></pre>
<pre><code class="language-groovy">//grails-app/domain/com/ociweb/Todo.groovy
    package com.ociweb

    class Todo {

        String name

        static belongsTo = [todoList: TodoList]
    }
</code></pre>
<pre><code class="language-groovy">//grails-app/domain/com/ociweb/TodoList.groovy
    package com.ociweb

    class TodoList {

        String name

        static hasMany = [ todos: Todo ]

        static constraints = {
            todos nullable: true
        }
    }
</code></pre>
<p>Now we have our domain model ready to go. By default Grails will provide us with an H2 database (in memory for development and test environments, as a file in production).</p>
<p>Of course Grails supports all the major databases, including MySQL, Postgres, Oracle, and even NoSQL data stores like <strong>Mongo</strong>. Thanks to the flexibility of GORM, changing datasources is as simple as adding a couple dependencies or lines of configuration.</p>
<p>Let’s switch to Mongo for this demonstration (this step is optional).</p>
<p>Specify the mongo plugin in your <code>build.gradle</code> file:</p>
<pre><code class="language-groovy">//build.gradle

    buildscript {
        //…
        dependencies {
            //…
            classpath &quot;org.grails.plugins:hibernate4:5.0.0.BUILD-SNAPSHOT&quot;

    dependencies {
    		//…
        compile &quot;org.grails.plugins:mongodb:5.0.0.BUILD-SNAPSHOT&quot;
        compile &quot;org.grails.plugins:hibernate4:5.0.0.BUILD-SNAPSHOT&quot;
</code></pre>
<p>Now in our domain classes, add this static property to store the domain object in mongo:</p>
<pre><code class="language-groovy">    //grail-app/domain/com/ociweb/Todo.groovy &amp; TodoList.groovy

//...
    static mapWith=&quot;mongo&quot;
</code></pre>
<p>The plugin assumes you have mongodb installed and that mongod is running at port 27017; you can configure these to match your environment (<a href="https://gorm.grails.org/latest/mongodb/manual/index.html">see the plugin documentation for details</a>).</p>
<h2>Defining Our API</h2>
<p>Finally, we need to define a restful API for our React application.</p>
<p>API design is a broad subject and not in scope of this article. However, Grails gives us a jumpstart to getting our API off the ground, providing endpoints for standard CRUD operations with minimal configuration. This is done by declaring our domain classes as resources, either by marking with the <code>@Resource</code> annotation or specifying the resource class within our URLMappings.</p>
<p>Let's use the <code>@Resource</code> annotation for this example.</p>
<pre><code class="language-groovy">//grails-app/domain/com/ociweb/Todo.groovy
    import grails.rest.Resource

    @Resource(uri='/api/todos', formats=['json'])
    class Todo {
      //...
</code></pre>
<pre><code class="language-groovy">//grails-app/domain/com/ociweb/TodoList.groovy

    @Resource(uri='/api/todoList', formats=['json'])
    class TodoList {
      //...
</code></pre>
<p>Note that we specify the content-type we wish to expose - we’ll use JSON.</p>
<p>Finally, let’s add some initial data in <code>Bootstrap.groovy</code>:</p>
<pre><code class="language-groovy">//grails-app/init/BootStrap.groovy

    import com.ociweb.*

    class BootStrap {

        def init = { servletContext -&gt;

            if(!Todo.list()) {
                log.info &quot;Creating todos...&quot;
                def todoList = new TodoList(name: &quot;Bob's List&quot;).save()

                [[name: &quot;Task 1&quot;, todoList: todoList],
                 [name: &quot;Task 2&quot;, todoList: todoList],
                 [name: &quot;Task 3&quot;, todoList: todoList]].each { props -&gt;
                    def todo = new Todo()
                    todo.properties = props
                    todo.save(flush: true)
                }

            }
        }
        def destroy = {
        }
    }
</code></pre>
<p>Restart the application to load the new data.</p>
<p>Now using a rest client application or a command-line utility like cURL, we can test drive our new API.</p>
<pre><code>    ~ curl -i -H &quot;Accept: application/json&quot; localhost:8080/api/todos

    HTTP/1.1 200 OK
    Server: Apache-Coyote/1.1
    X-Application-Context: application:development
    Content-Type: application/json;charset=UTF-8
    Transfer-Encoding: chunked
    Date: Sun, 15 May 2016 06:03:56 GMT

    [{&quot;id&quot;:1,&quot;list&quot;:{&quot;id&quot;:1},&quot;name&quot;:&quot;Task 1&quot;},{&quot;id&quot;:2,&quot;list&quot;:{&quot;id&quot;:1},&quot;name&quot;:&quot;Task 2&quot;},
    {&quot;id&quot;:3,&quot;list&quot;:{&quot;id&quot;:1},&quot;name&quot;:&quot;Task 3&quot;}]
</code></pre>
<pre><code>    ~ curl -i -H &quot;Accept: application/json&quot; localhost:8080/api/todoList/1

    HTTP/1.1 200 OK
    Server: Apache-Coyote/1.1
    X-Application-Context: application:development
    Content-Type: application/json;charset=UTF-8
    Transfer-Encoding: chunked
    Date: Sun, 15 May 2016 06:06:00 GMT

    {&quot;id&quot;:1,&quot;name&quot;:&quot;Bob's List&quot;,&quot;todos&quot;:[{&quot;id&quot;:3},{&quot;id&quot;:1},{&quot;id&quot;:2}]
    }
</code></pre>
<p>There you go, we have a fully functioning restful API, backed by Mongo, and my coffee isn’t even cold yet.</p>
<p>Now that we have our backend largely ready to go, we’re ready to set up React.</p>
<blockquote>
<p>Question: Why Do This?</p>
<p>Why not use separate backend and front-end apps? In a microservice architecture, the work we’ve done might be sufficient - we could now build a separate React/node-based front-end application independent of our Grails backend. This is a great strategy, and <a href="https://docs.grails.org/latest/guide/single.html#webApiAndAngularProfiles">Grails 3.1 ships with a profile</a> tailored to this use case (web-api). Another option is to take advantage of Gradle multi-project builds, with separate projects for the backend and front-end. Both of these options require another server to run the React app.</p>
<p>In this article, however, we’re considering the use of React as the “view” (the V in MVC) in a standard Grails application. And although we’re sharing a project directory, the React code and Grails artifacts are independent, and will communicate at runtime via our restful API just as if they were separate apps. The only thing tying these two apps together is the same Gradle build, which gives us the benefits described earlier in the article (in fact, it would be quite easy to split out the React app in future by simply moving the <code>src/main/js</code> and <code>src/test/js</code> directories into their own project, and configuring up a new server).</p>
<p>There’s many situations where a team may want to bring React into a Grails application, and it can be done in a way that allows for full developer productivity for both Grails and Node/React developers. Read on to see how!</p>
</blockquote>
<h2>Upgrading Our Build</h2>
<p>React is most commonly used in combination with <a href="https://nodejs.org/">node.js</a>, and even if you aren’t intending to use node in particular, it still makes sense to have it installed if you intend to do any serious work with a Javascript library like React.</p>
<p>The reason? You will use <code>npm</code> (which most surely <a href="https://www.quora.com/I-keep-hearing-NPM-doesnt-stand-for-Node-Package-Manager-what-does-it-stand-for">does <em>not</em> stand for Node Package Manager</a>) to download and install React and any other libraries you choose to use alongside it. <code>npm</code> can also be used to run scripts to build and test your React code, and it is the “handle” that will allow us to integrate our React code with our Gradle-based deployment.</p>
<p>Once we have our React application set up, it will <em>not</em> be necessary for all developers to run node on their machines – we’ll take care of making that happen seamlessly as part of the Gradle build. However, any developer who is set up with node will be able to use <code>npm</code> and other node tools just as if they were working within a “plain” node application. This gives us the best of both worlds: Backend Grails developers can do their work without relying upon node and <code>npm</code>, while frontend developers can use node and their preferred development tools. The only requirement for all team members will be a Gradle installation to run the Grails project.</p>
<p>In addition to installing node in your development environment, we will need to install the <a href="https://github.com/srs/gradle-node-plugin">gradle-node plugin</a> in our Grails application. This plugin will be the key to managing our <code>npm</code> tasks without relying upon local installations of node. Install the plugin by adding the plugin in <code>build.gradle</code>:</p>
<pre><code class="language-groovy">    //build.gradle

    plugins {
        id &quot;com.moowork.node&quot; version &quot;0.12&quot;
    }

    node {
        version = '5.10.1'
        npmVersion = '3.8.3'
        distBaseUrl = 'https://nodejs.org/dist'
        download = true
    }
</code></pre>
<h2>Setting Up Our React Environment</h2>
<p>For the next few steps, we'll use a local installation of <code>npm</code>. If you don't have it installed yet, I <em>highly</em> recommend <a href="https://github.com/creationix/nvm">nvm</a> to simplify installation and managing of node versions (if you've used <code>gvm</code>/<code>sdkman</code> for managing Grails/Groovy/Gradle versions, you'll like <code>nvm</code>). We'll be using the latest version of node 5.x as of the time of writing, which is 5.10.1. Please refer to <a href="https://github.com/ZacharyKlein/sett-todolist/blob/master/README.md">the Readme in the Github repository</a> for the versions of all node packages that are used. For a simple example like this, newer versions of any of the packages shouldn't cause a problem.</p>
<p>Assuming you've installed <code>npm</code>, let's initialize our project. Run this command from your Grails project directory - you can accept the defaults for now; it's easy to fill in the details later):</p>
<pre><code>    npm init
</code></pre>
<p>Now we’re ready to install React and other dependencies.</p>
<pre><code>    npm install react react-dom --save

    npm install babel-core babel-preset-es2015 babel-preset-react babel-loader webpack --save-dev
</code></pre>
<p>There are plenty of options when setting up a React application, but these are the basics.</p>
<p>Of course we need React and ReactDOM to render our app in the browser (React can also be used natively on mobile platforms like iOS, using <a href="https://facebook.github.io/react-native/">ReactNative</a> instead of ReactDOM).</p>
<p>In addition, because we’ll be using JSX to write our components, we’ll need to use a <strong>transpiler</strong> to convert our React code into “plain vanilla” Javascript. Modern Javascript frameworks are moving much faster than web browsers, and many of the Javascript APIs commonly used in React projects are not yet standard in browsers.</p>
<p><a href="https://babeljs.io/">babel</a> is a popular transpiler with many “presets” supporting different versions of Javascript syntax.</p>
<p>To enable these presets, create a <code>.babelrc</code> file in the project root directory with this content:</p>
<pre><code class="language-javascript">    {
      &quot;presets&quot;: [
        &quot;react&quot;,
        &quot;es2015&quot;
      ]
    }
</code></pre>
<p>This will ensure that babel uses the presets we’ve installed when transpiling our code.</p>
<p>Of course, if we’re going to run our code through a transpiler, that means we need a build step to do the work. Typically in Grails applications, the asset pipeline plugin is the tool of choice for processing static assets like Javascript files. While there is a <a href="https://github.com/errbuddy/babel-asset-pipeline">Babel plugin</a> for the Grails asset pipeline, we are going to take a different approach and use **webpack **for this purpose; this will give us more flexibility in processing our React code and is in keeping with typical React projects.</p>
<h2>Webpack</h2>
<p><a href="https://webpack.github.io" title="Webpack on GitHub">Webpack</a> represents a family of tools called “bundlers” and is a very popular choice for building React applications. It’s also a powerful and complex tool, but we can get started with a fairly minimal configuration.</p>
<p>Here’s the big picture: Webpack will be responsible for running our React code through “loaders” for processing, and then output the finished product as a “bundle”. There are <a href="https://webpack.js.org/loaders/">loaders for nearly every conceivable asset type</a> you may want to access in your React application, including LESS, SASS, markdown, images, urls, generic files, and even Java properties files (such as <code>i18n/messages.properties</code> files). In our case, the babel-loader all we need to configure right now. We will configure webpack to drop this bundle into the <code>grails-app/assets/javascripts</code> directory in our Grails application, so it can be served just like another Javascript file.</p>
<p>Here's our <code>webpack.config.js</code> file:</p>
<pre><code class="language-javascript">    var path = require('path');

    module.exports = {
        entry: {
            index: './src/main/js/index.js'
        },
        output: {
            path: './grails-app/assets/javascripts',
            publicPath: '/assets/',
            filename: 'bundle.js'
        },
        module: {
            loaders: [
                {
                    test: /\.js$/,
                    include: path.join(__dirname, 'src/main/js'),
                    loader: 'babel',
                    query: {
                        presets: ['es2015', 'react']
                    }
                }
            ]
        }
    };
</code></pre>
<p>Don't be intimidated by this configuration; it’s actually fairly simple. The syntax is plain Javascript, which can be a bit confusing for a Grails developer accustomed to a DSL for config. The key points are that we’re defining where to find our React source files (<code>src/main/js/index.js</code>), where to output them (<code>grails-app/assets/javascripts</code>), and how to process them via the babel loader. You can learn more about configuring webpack <a href="https://webpack.js.org/concepts/">from the documentation</a>, but this should get you started.</p>
<blockquote>
<p>Where Is <code>/src/main/js</code>?</p>
<p>Typically in a Grails application, Javascript files, like other static assets, live in the <code>grails-app/assets/</code> directory, which is where the asset pipeline picks them up. However, it is far more typical in a React application to keep the source files separate from the distributed bundle within a <code>src</code> directory, which makes sense, given that they contain “source code” for an application and are not really “assets” in the sense that Twitter Bootstrap or jQuery might be.</p>
<p>In addition, we will want to write tests for our React code, and it really doesn't make sense for tests to live in an “assets” directory structure. This is simply a matter of preference; in this article, we will store our React source code under <code>src/main/js</code> (in keeping with Grails' conventional <code>src/main/java</code> and <code>src/main/groovy</code> source structure), and our tests under <code>src/test/js</code>. These directories won’t exist by default, so we’ll need to create them ourselves.</p>
</blockquote>
<p>We will also want to add a couple of “scripts” to our <code>package.json</code> file in order to run webpack via <code>npm</code> (and later automate these with Gradle). In the <code>scripts</code> section, add these two lines:</p>
<pre><code class="language-javascript">      &quot;scripts&quot;: {
        &quot;watch&quot;: &quot;webpack --watch --colors --progress&quot;,
        &quot;bundle&quot;: &quot;webpack&quot;,
</code></pre>
<p>Now we can call these scripts using <code>npm</code>. Why do we have two scripts that both run webpack? The “bundle” version runs webpack and generates the bundle once (analogous to <code>grails war</code>), while the “watch” version will run webpack in “watch” mode, where the tool will automatically regenerate the bundle every time it detects a change to the source files (similar to <code>grails run-app</code>, with reloading of changed classes). We also enable some pretty formatting to ensure developer happiness.</p>
<p>You can now run these scripts like so:</p>
<pre><code>    npm run bundle
</code></pre>
<p>However, you'll likely get an error saying &quot;Entry module could not be found.&quot;</p>
<p>Yep, we haven't added the &quot;entry&quot; file we specified earlier in our <code>src/main/js</code> directory yet. Let's do that.</p>
<p>Create <code>index.js</code> and add a simple <code>alert()</code> statement:</p>
<pre><code class="language-javascript">//src/main/js/index.js
    alert('Hello!');
</code></pre>
<p>Now if you run <code>npm run bundle</code>, you’ll get output like this:</p>
<pre><code class="language-javascript">    Hash: bc17d737c7738edc00a5
    Version: webpack 1.13.0
    Time: 727ms
        Asset     Size  Chunks             Chunk Names
    bundle.js  1.43 kB       0  [emitted]  index
        + 1 hidden modules
</code></pre>
<p>And if you check your <code>grails-app/assets/javascripts</code> directory, you should see your shiny new <code>bundle.js</code>!</p>
<p>Finally we need to load this bundle on our page. We’ll use a Grails controller and GSP view in this demonstration, but this could easily be a plain HTML page as well. Create a new controller <code>AppController</code>, and create an <code>index.gsp</code> page in the <code>grails-app/views/app</code> directory with this content:</p>
<pre><code>    grails create-controller com.ociweb.AppController
</code></pre>
<pre><code class="language-groovy">//grail-app/views/index.gsp
    &lt;!doctype html&gt;
    &lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Todo List&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
        &lt;asset:javascript src=&quot;bundle.js&quot; &gt;&lt;/asset:javascript&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<p>(Note that if we had used a plain HTML page, we would not be able to use the tag)</p>
<p>Browse to <a href="http://localhost:8080/app"><code>http://localhost:8080/app</code></a>, and you should see your <code>alert()</code> statement.</p>
<blockquote>
<p>webpack-dev-server</p>
<p>Webpack also includes a simple server called <em>webpack-dev-server</em>, which will operate similarly to “watch” mode but is actually able to instantly reload the bundle/s on your page, so that you can see your app update when you save your source file <a href="https://gaearon.github.io/react-hot-loader/getstarted/">without refreshing the browser</a>. This is a powerful feature, but it can be tricky to set up and is outside the scope of this article. I’ve created <a href="https://github.com/ZacharyKlein/grails-react-starter">a starter application available on Github</a>[2] that demonstrates use of the webpack-dev-server within a Grails application.</p>
</blockquote>
<h2>Enter Gradle</h2>
<p>We’re almost done with our setup steps. With our current configuration, we can bundle our React code and output it to the asset pipeline, so the Grails app can serve it to our views. We also have a restful backend provided by our Grails app. Now we just need to make use of the Gradle node plugin [3] to automate the webpack bundling process when we 1. start the Grails app, and 2. package the Grails app as a WAR or JAR file.</p>
<p>Add these two lines to the end of your <code>build.gradle</code>:</p>
<pre><code class="language-groovy">//build.gradle

    processResources.dependsOn(['npmInstall', 'npm_run_bundle'])

    assetCompile.dependsOn(['npmInstall', 'npm_run_bundle'])
</code></pre>
<p>And that’s it! All we’ve done here is “hooked” a pair of <code>npm</code> tasks into our Gradle build process.</p>
<p>The first is <code>npmInstall</code>, which is the equivalent of <code>npm install</code>, and is typically the first command you’d run when setting up an existing node-based project. <code>npm install</code> will read the <code>package.json</code> file and install any missing dependencies in your development environment.</p>
<p>The second task should look familiar – it’s our <code>bundle</code> script we just used a moment ago. The Gradle node plugin supports this syntax for <em>any</em> script that you would normally run with <code>npm</code>. So any custom scripts you write in the future can be called via <code>npm_run_[your new script]</code>.</p>
<p>Of course, you can run these scripts yourself through Gradle, using the included Gradle wrapper:</p>
<pre><code>    ./gradlew npm_run_watch
</code></pre>
<p>Other than the delay from spinning up Gradle, this will have the same effect as running <code>npm run watch</code> directly. This also means that developers without node installed can run these tasks without adding anything to their build environment - Gradle will handle those details seamlessly and OS-independently.</p>
<p>When developing with React, typically you will run the Grails app <em>and</em> run webpack in “watch” mode, using <code>npm</code> or Gradle. As you make changes to your Javascript sources, webpack will automatically regenerate the <code>bundle.js</code>, and you can load the changes by refreshing your page.</p>
<p><img src="2016-05-28-img01.png" alt="" />
<em>Development Workflow with Grails &amp; Webpack (<code>grails run-app</code> in the left terminal; <code>./gradlew npm_run_watch</code> in the right)</em></p>
<p>Returning to our new <code>build.gradle</code> steps, you'll notice that we've attached these tasks to Grails' <code>processResources</code> (which runs every time the Grails app is started) and <code>assetCompile</code> (which runs when the app is packaged) tasks as dependencies. In this case, we just want to make sure the bundle is generated when the app is run, and when we build our WAR/JAR file, so that we’re always using our latest <code>bundle.js</code>. This also means you can exclude <code>bundle.js</code> from your version control if you’d prefer.</p>
<p>Now you can build your Grails application on a Continuous Integration server that knows nothing about node or React. Gradle will handle installing node (local to the project), downloading <code>npm</code> dependencies, and running scripts like our webpack bundle, all without any changes to your build and deployment process.</p>
<h2>Defining our Components</h2>
<p>As we mentioned in the introduction to this article, React provides an <a href="https://facebook.github.io/react/docs/jsx-in-depth.html">expressive XML-like syntax</a> for defining our components. Let’s take a look at a simple JSX component that will render a Todo instance.</p>
<pre><code class="language-javascript">    // /src/main/js/todo.js

    import React from 'react';

    function Todo(props) {

        const todo = props.todo;

        return(
            &lt;li&gt;
                &lt;input id={ todo.id } type=&quot;checkbox&quot;
                checked={ todo.complete ? 'checked' : '' }
                onChange={ props.toggleComplete } /&gt;
                &lt;span&gt;{ todo.name }&lt;/span&gt;
            &lt;/li&gt;
        );
    }
</code></pre>
<p>Again, this is not an in depth explanation of React and JSX, but you can learn a lot from a simple example like this one. As you can see, our component is a simple Javascript function, which takes an object (key/value pairs, similar to a Groovy map) that contains all attributes that are passed into this component.</p>
<p>To use our new component, we just need to render it to our page (note that we have implemented a <code>toggleComplete</code>function yet, so we’re skipping that property for now - our  component will still render but it won’t do anything yet):</p>
<pre><code class="language-javascript">    // /src/main/js/index.js

    import React from 'react';
    import ReactDOM from 'react-dom';
    import Todo from './todo';

    //Call to render our component into the DOM…
    ReactDOM.render(
    &lt;div&gt;

    &lt;h1&gt;Our first Todo!&lt;/h1&gt;
{% raw %}
    &lt;Todo todo={{name: 'Task 1', id: 1, complete: false}}&gt;&lt;/Todo&gt;
{% endraw %}
    &lt;/div&gt;, document.getElementById('app')); // ...into this element on the page
</code></pre>
<p>Compare this to a custom GSP tag that might render similar output server-side:</p>
<pre><code class="language-groovy">    //Hypothetical GSP taglib

    def todo = { attrs -&gt;

    	def todo = attrs.todo

    	out &lt;&lt; &quot;&quot;&quot;
      &lt;li&gt;
        &lt;input type=&quot;checkbox&quot;
    			checked=${todo.complete ? 'checked' : ''}
    			onchange=${ /* specify an Ajax function */} /&gt;
    			&lt;span&gt;${todo.name}&lt;/span&gt;
    	  &lt;/li&gt;
    		&quot;&quot;&quot;
    }

    &lt;g:todo todo=${todo} &gt;&lt;/g:todo&gt;
</code></pre>
<p>Of course this is not an entirely fair comparison. <a href="https://objectcomputing.com/resources/publications/sett/december-2015-custom-gsp-tags-grails-best-kept-secret/">GSP tags provide much more functionality</a> than simply rendering of attributes, but Grails developers should find the syntax of JSX to be quite friendly and understandable coming from GSPs.</p>
<p>JSX allows us to write Javascript expressions bound by curly braces, supports namespacing of components, and can make large, complex UIs easier to visualize while coding [4]. However, JSX is optional. You can write React components entirely in plain Javascript, but the resulting code is more verbose.</p>
<blockquote>
<p>Word of Warning</p>
<p>This article is not intended as a comprehensive introduction to React. For developers new to Javascript, there are plenty of pitfalls to be had when learning this library. Understanding function context, &quot;binding&quot; [5], and passing functional callbacks into child components are key skills when writing clean code in React. These concepts are not React-specific – they are in fact plain Javascript – but they can be confusing to Groovy and Java programmers. There are many resources for learning React, and we will list a few of them at the end of this article.</p>
</blockquote>
<h2>Calling the API</h2>
<p>Now that we have our React app integrated into our Grails project and served up via the asset pipeline, we can start to build out our application and write components that consume our restful API. Because React is a view library, it doesn’t offer specialized features for communicating with a restful API. Developers are encouraged to use native Javascript APIs or other libraries to supply this functionality. The example project from this article uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">fetch API</a> [6]. The full code is available on Github, so we won’t go over it here.</p>
<p>The app allows a user to create new todo lists and add new todo items to them. All changes are saved to the mongo database. It also makes use of <a href="https://views.grails.org/latest/">JSON Views</a> to customize the JSON output from our endpoints.</p>
<p>No update or delete functions are provided at this time. Those features are left as an exercise to the reader.</p>
<p><a href="https://github.com/ZacharyKlein/sett-todolist">https://github.com/ZacharyKlein/sett-todolist</a></p>
<p><img src="2016-05-28-img02.png" alt="" /></p>
<p>Completed TodoList app</p>
<h2>Testing</h2>
<p>One of the benefits of creating a user interface in React is testability. Because React encourages the use of stateless components, testing their functionality is often as simple as providing props and making assertions against their output. Let’s look at a simple test for our  component, and then see how the Gradle node plugin can help us run our tests as part of our build.</p>
<p>There are many options for testing Javascript code. [7,8] In this example we'll use the <a href="https://mochajs.org/">mocha test framework</a>, React’s own <a href="https://facebook.github.io/react/docs/test-utils.html">testing utilities</a>, and <code>expect.js</code> to provide assertions.</p>
<p>Again, because React is focused on building our view layer, we’re mostly concerned with testing that our components output the correct content from their props. This is <em>not</em> an in-depth look at testing React components, but it will give you a place to start.</p>
<p>First, let’s install some dependencies:</p>
<pre><code>    npm install mocha expect react-addons-test-utils --save-dev
</code></pre>
<p>And add this &quot;test&quot; script to our <code>package.json</code> file:</p>
<pre><code>    ”test&quot;: &quot;mocha './src/test/js/*.spec.js' --compilers js:babel-core/register&quot;
</code></pre>
<p>Here's a simple test for our component:</p>
<pre><code class="language-javascript">    // /src/test/js/lot.spec.js

    import React from 'react';
    import TestUtils from 'react-addons-test-utils';
    import expect from 'expect';
    import Todo from '../../main/js/todo';

    describe('Todo', () =&gt; {
        it('should have expected content', () =&gt; {

            const todo = {name: 'Task 1', complete: false, id: 1, list: { id: 1 }};

            const renderer = TestUtils.createRenderer();

            renderer.render(
                &lt;Todo todo={todo} &gt;&lt;/Todo&gt;);

            const output = renderer.getRenderOutput();

    				//We expect the &lt;Todo&gt; to output an &lt;li&gt; element
            expect(output.type).toBe('li');

            const children = output.props.children;
            const [input, span] = children;

    				//We expect the first element in our &lt;li&gt; to be an input
            expect(input.type).toBe('input');

            const todoName = span.props.children;

    				//We expect the span to contain the name of the todo
            expect(todoName).toBe(todo.name);
        });
    });
</code></pre>
<p>There’s a lot to unpack here that is beyond the scope of this article, so I’ll refer you to the resources at the bottom of the page for more detail. But the big picture is fairly simple. We’ve created a “mock” todo object, and used it to populate our component, which is then “rendered” using <code>TestUtils.createRenderer()</code> (<code>TestUtils</code> also includes features for simulating clicks and other user interactions with your components). At that point, we’re simply traversing the “DOM” and making assertions about the expected content.</p>
<p>To run this test, use <code>npm</code> to run our new <code>test</code> script:</p>
<pre><code>    npm run test
</code></pre>
<pre><code class="language-javascript">    &gt; todo-list@1.0.0 test /Users/zak/Dev/TodoList
    &gt; mocha './src/test/js/*.spec.js' --compilers js:babel-core/register

      Todo
        ✓ should have expected content

      1 passing (15ms)
</code></pre>
<p>Finally, we can add this test script to our Gradle build using the same techniques we explored earlier.</p>
<pre><code class="language-groovy">    //build.gradle

    //Run React tests
    task mochaTest(dependsOn: ['npmInstall', 'npm_run_test'])

    check.dependsOn(mochaTest)
</code></pre>
<p>Now we can run our React tests via Gradle with <code>./gradlew mochaTest</code>, and they will also be run as part of the <code>check</code> task (which runs Grails unit and integration tests together).</p>
<h2>Conclusion</h2>
<p>React is a powerful and exciting library, and it’s a great choice for Grails applications. While there’s some bootstrapping necessary to get started, with a project structure like we’ve demonstrated you should be able to take advantage of the many resources available for learning React and associated libraries and tools, without having to “translate” into a Grails-specific flavor. In addition, front-end developers unfamiliar with Grails should find it much easier to work using their favorite node-based tools and development environments. The only requirement to firing up the backend is Java and the Gradle wrapper that is included in the Grails project. With React’s tooling standardized around <code>npm</code>, and Grails’ build process managed by <code>Gradle</code>, it’s quite straightforward to set up a combined development and deployment pipeline, one that allows both frameworks to be used as designed.</p>
<blockquote>
<p>Postscript</p>
<p>As mentioned earlier in the article, I've created a <a href="https://github.com/ZacharyKlein/grails-react-starter">starter project</a> with React integrated in a Grails application, using the same structure described above. It also provides a working configuration for the <code>webpack-dev-server</code>, including a custom taglib to switch between the “hot load” bundle and the static bundle from the Grails asset pipeline. React-Bootstrap and loading of images and CSS are also demonstrated. The project is available on Github. [2]</p>
</blockquote>
<h2>References</h2>
<ul>
<li>[1] Sample App: <a href="https://github.com/ZacharyKlein/sett-todolist">https://github.com/ZacharyKlein/sett-todolist</a></li>
<li>[2] Grails-React Starter: <a href="https://github.com/ZacharyKlein/grails-react-starter">https://github.com/ZacharyKlein/grails-react-starter</a></li>
<li>[3] Gradle-node-plugin: <a href="https://github.com/srs/gradle-node-plugin">https://github.com/srs/gradle-node-plugin</a></li>
<li>[4] JSX and “Separation of concerns”: <a href="https://blog.andrewray.me/youre-missing-the-point-of-jsx/">https://blog.andrewray.me/youre-missing-the-point-of-jsx/</a></li>
<li>[5] Why and how to bind methods in your React component classes?: <a href="https://reactkungfu.com/2015/07/why-and-how-to-bind-methods-in-your-react-component-classes/">https://reactkungfu.com/2015/07/why-and-how-to-bind-methods-in-your-react-component-classes/</a></li>
<li>[6] Fetch API: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch</a></li>
<li>[7] How we unit test React components using expect-jsx: <a href="https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/">https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx</a></li>
<li>[8] How React Components Make UI Testing Easy <a href="https://www.toptal.com/react/how-react-components-make-ui-testing-easy">https://www.toptal.com/react/how-react-components-make-ui-testing-easy</a></li>
</ul>
<h2>Resources</h2>
<ul>
<li>OCI Training in React Web Development: <a href="https://ocitraining.com/react-web-development/">https://ocitraining.com/react-web-development</a></li>
<li>Egghead.io video courses on React and related technologies: <a href="https://egghead.io/q/react">https://egghead.io/q/react</a></li>
<li>Navigating the React.JS Ecosystem: <a href="https://www.toptal.com/react/navigating-the-react-ecosystem">https://www.toptal.com/react/navigating-the-react-ecosystem</a></li>
<li>An excellent set of sample React apps written and maintained by my OCI colleague, Mark Volkmann: <a href="https://github.com/mvolkmann/react-examples">https://github.com/mvolkmann/react-examples</a></li>
<li>RubyC presentation by <a href="https://alexbcoles.com/">Alex Coles</a>, “Beyond the Asset Pipeline” (Rails-specific talk, but much of the discussion is relevant to the Grails asset pipeline as well): <a href="https://youtu.be/CNv9ewmQys8">https://youtu.be/CNv9ewmQys8</a></li>
<li>How to Use Webpack with Rails (also Rails-specific, but many of the techniques described are relevant to Grails projects): <a href="https://clarkdave.net/2015/01/how-to-use-webpack-with-rails/">https://clarkdave.net/2015/01/how-to-use-webpack-with-rails/</a></li>
</ul>
<h2>Documentation</h2>
<ul>
<li>React Documentation: <a href="https://github.com/ZacharyKlein/grails-react-starter">https://facebook.github.io/react/docs/getting-started.html</a></li>
<li>React Test-Utils: <a href="https://facebook.github.io/react/docs/test-utils.html">https://facebook.github.io/react/docs/test-utils.html</a></li>
<li>JSX Documentation: <a href="https://github.com/ZacharyKlein/grails-react-starter">https://facebook.github.io/react/docs/jsx-in-depth.html</a></li>
<li>Webpack Documentation: <a href="https://webpack.js.org/concepts/">https://webpack.js.org/concepts/</a></li>
</ul>
    <h2 class='space-above'>
      <span>You might also like ...</span>
    </h2>
    <div class='threecolumns'>
      <div class='column'><article class='blogcard' style='background-image: url(https://grails.staged.apache.org/images/2018-02-09.jpg)'>
  <a href='https://grails.staged.apache.org/blog/2018-02-09.html'>
    <h3>February 9, 2018</h3>
    <h2>Webinar: Developing React Apps with Grails® 3</h2>
  </a>
</article></div>
      <div class='column'><article class='blogcard' style='background-image: url(https://grails.staged.apache.org/images/2017-11-21.jpg)'>
  <a href='https://grails.staged.apache.org/blog/2017-11-21.html'>
    <h3>November 21, 2017</h3>
    <h2>Grails® React Profiles</h2>
  </a>
</article></div>
      <div class='column'><article class='blogcard' style='background-image: url(https://grails.staged.apache.org/images/quickcast.jpg)'>
  <a href='https://grails.staged.apache.org/blog/2017-10-30.html'>
    <h3>October 30, 2017</h3>
    <h2>Quickcast #8: Grails® React Profile</h2>
  </a>
</article></div>
    </div>
  </div>
</div>&nbsp;</article>
<footer>
    <div class='content'>
        <div class='apache-grails'>
            <p>The Apache Grails Framework is incubating at the Apache Software Foundation, sponsored by the <a href="http://groovy.apache.org" target="_blank">Apache
                Groovy</a> project. Incubation is required of all newly accepted projects. It is supported by the Grails community.</p>
            <a href='https://apache.org'><img class='' src='https://grails.staged.apache.org/images/asf_logo.svg' width='300px'
                                              alt='Apache Software Foundation'/></a>
            <p>The Apache Software Foundation</p>
            <p>Apache, Apache Grails, Grails, and the Apache feather logo are either registered trademarks or trademarks
                of The Apache Software Foundation.
            </p>

        </div>
        <nav class='socialmedianav'>
            <ul>
                <li>
                    <a href='mailto:dev@grails.apache.org'><img class='' src='https://grails.staged.apache.org/images/email.svg' alt='Email Icon'/></a>
                </li>
                <li>
                    <a href='https://slack.grails.org'><img class='' src='https://grails.staged.apache.org/images/slack.svg'
                                                            alt='Slack Icon'/></a>
                </li>
                <li>
                    <a hre f='https://www.youtube.com/@GrailsFramework'><img class='' src='https://grails.staged.apache.org/images/youtube.svg'
                                                                             alt='Youtube Icon'/></a>
                </li>
                <li>
                    <a href='https://www.linkedin.com/showcase/official-grails/'><img class=''
                                                                                      src='https://grails.staged.apache.org/images/linkedin.svg'
                                                                                      alt='LinkedIn Icon'/></a>
                </li>
                <li>
                    <a href='https://github.com/apache/grails-core'><img class='' src='https://grails.staged.apache.org/images/github.svg'
                                                              alt='Github Icon'/></a>
                </li>
                <li style="margin-bottom:10px;">
                    <a href='https://twitter.com/grailsframework'><img class='' src='https://grails.staged.apache.org/images/x-twitter.svg'
                                                                       alt='Twitter Icon'/></a>
                </li>
            </ul>
        </nav>
    </div>
    <div class="content">
        <nav class='footer' style="margin-bottom: 10px">
                <p>© 2005-2025 the Apache Grails project — Grails is Open Source: 
                    <a href="https://www.apache.org/licenses/LICENSE-2.0.html">License</a>,
                    <a href='https://privacy.apache.org/policies/privacy-policy-public.html'>Privacy Policy</a>,
                    <a href='https://www.apache.org/foundation/sponsorship'>Sponsor Apache</a>
                </p>
        </nav>
    </div>
</footer>
<div>

</div>
</body>
</html>
